{"name":"Reflect","tagline":"C++ Data Reflection Header-Only Library","body":"#Reflect C++\r\n\r\nC++ offers many powerful ways to express ideas.  One idea it does not directly support, however, is reflection.\r\n\r\nC++’s RTTI does help support a traditional reflection implementation (similar to java.lang.reflect), but actually achieving reflection is left as an exercise for the engineer. \r\n\r\nThis reflection library was designed to meet three design goals:\r\n\r\n1 - Store any POD type and support storing more complex types. \r\n2- Support generic stream output.  \r\n3- Bind directly to data so that values are shared. \r\n\r\nIn the end, what I want is to be able to put just about anything into a single container and output the container’s contents to a stream.\r\n\r\n##Variant\r\n\r\nA Variant is class which has multiple types, but a single value.  A very basic variant could be represented with a union.  However, a union does not support non-POD types with trivial constructors and destructors.\r\n\r\nVariants implementations attempt to solve this problem.  And, while a Variant supports storage of non-trivial types, they generally do not support generic stream output.  Further, they are generally implemented as copies of data.  And that is not what is desired here.  We want a reference to the data.\r\n\r\nboost::variant largely meets the requirements motivating the development of Reflect.  However, data lacks reflection. \r\n\r\n##Any\r\n\r\nAny classes can contain different types but to not attempt to convert between them.  They tend to ignore their interpretation yet retain knowledge of their underlying type.  This is useful for putting arbitrary values into data structures.  However, as with Variants, do not bind to the original data and the lack of conversion can be inconvenient. \r\n\r\nboost::any is an example implementation of this idea.  From boost.org documentation: “Values are strongly informational objects for which identity is not significant, i.e. the focus is principally on their state content and any behavior organized around that. Another distinguishing feature of values is their granularity: normally fine-grained objects representing simple concepts in the system such as quantities.\r\nAs the emphasis of a value lies in its state not its identity, values can be copied and typically assigned one to another, requiring the explicit or implicit definition of a public copy constructor and public assignment operator. Values typically live within other scopes, i.e. within objects or blocks, rather than on the heap. Values are therefore normally passed around and manipulated directly as variables or through references, but not as pointers that emphasize identity and indirection.”\r\n\r\n##Reflect\r\n\r\nThe solution here is the Reflect header-only library.  (Designing the library header-only allows for much easier integration into projects without pulling along dependencies and complex builds.) A Variant type is very close to what we need here, but instead of storing a copy of a value, we will hold a reference to a value.  If this sounds dangerous, it is because it is.\r\n\r\nIf the value whose reference lives inside Reflect goes out of scope, we can hope for an exception to be thrown.  Worst case, we march on referencing bad memory.  The Reference project contains googleTest code which demonstrates when exceptions can be expected:","google":"UA-41563573-1","note":"Don't delete this file! It's used internally to help with page regeneration."}